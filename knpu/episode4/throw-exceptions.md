# Throw Exceptions

In index.php, we created this broken ship object. I'm going to do something crazy, guys. I'm going to say, broken ship, set strength, which is a strength number, and I'm going to pass it to string. Banana. That makes no sense. If we try to battle this against somebody, it should explode. If I refresh, it does explode ... But not exactly in the way that I expect. See, it's coming from abstract ship line 65, so let's open that up. OK, cool. 2 cool things to look at here. 1: We planned ahead. When we set up the set strength method, we said, "You know what? This needs to be a number, so if somebody passes something stupid like "banana," then let's check for that and let's throw an error. In order to throw an error, we threw an exception, and that's actually what I want to talk about, is these exception classes, which are special.

However, we also forgot to add our slash when we converted this to name spaces, because the exception class, like the PDO class, is a core PHP class. It lives in the root of the name space. We do that, this is what I actually wanted to show you, which is, uncaught exception with message invalid strength past past banana. When things go wrong, we throw exceptions. Why? Well, first of all, it kills the page and it shows us a nice exception. Second of all, exceptions have really really nice benefits. For example, if I wanted to kind of kill the page here with an error, I really only have 2 options. I can either throw an exception, or I could print the exception of the page and do a die statement, for example, but when you do the die statement, there's really no handling of the exception you can do. With exceptions, there's lots of ways that you can control things.

Let me show you a different example. Let's go into PDO ship storage, and inside fetch all ships data, let's say "foooo" for the table name. Which is clearly not the right table name. This ship's storage is called from our ship loader. ... Inside of gear ships. If I do nothing else right now, we get an exception; a PDO exception that says "base table or view not found." You can see that it's coming from PDO ship storage line 18, but also was called on ship loader line 23. Perfect. Now, first thing you need to know about exception classes. What if we knew that sometimes we would get this exception class when we called fetch all ships data and we didn't want it actually to kill the page. What if we basically say, "Look, sometimes there are database problems, and if there are, instead of it killing the whole page, we just want to show no ships on the page temporarily. How could we stop the exception from being thrown? The answer is to catch it, and it looks like this.

You surround the line or lines of code that you think might fail with a try catch block. You catch /exception "e." ... What happens here is, if the ship's data equals line throws an exception, instead of throwing an exception, it will drop down here to the catch block, and we can continue our work like normal. For example, we could say, "ships=empty array." ... Could say ... "ship data=empty array." ... Just like that, everything works again. That's the power of exceptions. When you throw an exception, every layer, as it goes all the way back up to the top, has the opportunity to catch the exceptions; say "No no no no no, that's not what I want to happen." Now, of course, we probably don't want this failing silently, so we might want to trigger an error to our error log, so the easiest way to do that is just to say, "exception!" Then notice, it passes us the exception object that was thrown, so you can say, "E, get message" on that. Every exception object always has a get message method.

We refresh, you can see our error show up on top. If this were production, I would have my PHB.ini settings set for "display errors=false," so that that didn't show here, but did show at least in my webserver log. Let's see a little bit more about this exception class. I'm actually going to [inaudible 00:05:39] the E object here and print that. You can see it's an object called "PDO exception." First thing; exceptions are always objects. In every exception class, ultimately extends this base/exception class, so PDO exception, if you could look at its source code, extends the exception class. The purpose of having different exception classes is that we can catch different situations. Let's go back here and suppose that sometimes, we know we have database problems, but those are the only types of exceptions that we want to catch. If something else goes wrong, like some file system problem or something else, we don't want to catch that exception, because that is very much unexpected. To do that, we can change this to PDO exception.

Then, I'll change our message here to database exception. For refresh, it still catches that exception, but check this out. If I go back into PDO ship storage, and before I make the query, let's do a throw new, let's throw a different exception class. There's one called "invalid argument exception. We'll say something else went wrong. This invalid argument exception isn't special in any way; it's a core PHP exception and it extends exception. Now, it will not be caught by our PDO exception, because ... valid exception and PDO exception are just 2 totally separate classes. We refresh now, you can see it totally kills the page. Exceptions are something that you'll get used to more and more. The key things I want you to take away are, when things go wrong, throw an exception.

Oftentimes I see people try to not throw an exception and try to recover in some way. I would rather throw an exception and then catch the error in my error log, than try to render the page in some way and I never realize that there's a bug in my code. The second thing is, as you get more advanced with exceptions, you'll realize that you can actually control exceptions and catch them in really cool ways. For now, let's fix our code, take out the throw new statement, we'll change this back to ship and we are good to go.

