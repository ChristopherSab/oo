# Array Access Iterator Aggregate

Let's do something else that we shouldn't do. Battle result, that's an object but if you look at it and use your imagination, it is a class but its real job is just to hold these three properties. It also has one extra get, is there a winner method down there, but for the most part, it's kind of a glorified associative array. What if I said that I wanted to be able to treat it like an array and say battle results, let's go bracket, winning ship [inaudible 00:00:34] bracket, arrow, your name. Now that's craziness. In real life I wouldn't even try to do this but I want to show you that it's possible and you will see legitimate use cases for this. First of all, if we refresh, we're going to have no fun. You'll see this error occasionally if you make a mistake. Cannot use object of type battle result as array and that's exactly what we're trying to do.

After our last part about magic methods, you might expect me to go into battle results and add some new magic method down here at the bottom that would allow it to be treated like an array. That's not what we're going to do but it's a very, very similar idea. In fact there's two ways to add special behavior to your classes and some are done one way and some are done the other way. The other way is to make your class implement in interface. There's a bunch of different interfaces inside of PHP that give your classes different behavior. Probably the most famous one is implements slash array access. Array access is a core PHP interface.

Of course, we know as soon as you implement an interface, the interface is going to require you to have some classes. In this case PhpStorm was telling me that I needed offset good, offset unset, offset exist and offset set. Behind the scenes once we create those, we are going to be able to treat our battle result object like an array and PHP will call those methods behind the scenes in order to do things that it needs to do. Now I'm not going to actually add those by hand. I'm going to use a shortcut in my editor which is navigates code generates. I'm going to just like implement methods and I'm going to select those four methods down here, cool.

Now effectively what I'm going to do is I'm going to make any of my properties up here be valid array keys. For ops that exist we'll return a function called property exists this, comma offsets. Offset will be whatever property name is passed. Property exists is cool. It just checks, does that property exist on its object. Offset get, return this arrow, offset, offset set, even though we really don't want that. This arrow offset equals value and offset unset which would be unset this arrow offset. Not something you do very often but technically you can unset a property. You see this is a little bit weird but technically it works. Don't run and add that everywhere but you will have some cases where this might be handy. More importantly you'll see this in outside libraries. You want to know that even though sometimes it looks like something in an array, it might not be an array.

I'm going to show you a different example. Right now in ship loader get ships we return an array. Instead of returning an array I'm going to return an object, a new ship collection object. Don't ask why yet. I'll show you why this might be a good solution in a second. First I'll go to new PHP class and I'll type ship collection. Now PhpStorm Storm already guessed correctly that this should go in the model name space because it understands that standard. Make sure you have your name space above there. Now here [inaudible 00:04:15] a private ship's property which is going to be an array of ship objects and remain a public function underscore, underscore, construct. This will take in the array of ships and it'll set those on the ship's property. Above ships, just to help us with some auto-complete later, I'm going to add some PHP Doc that says this is an array of abstract ships.

You can see this is a class but the only purpose of this class is just to hold an array so it's a wrapper around an array. Now in ship loader instead of returning that array I'm going to return a new ship collection. I'm going to pass it that ship's object. Now stop right there. In reference again new class inside of the ship loader so I'm going to need a use statement for it. If you go up you need to add a use statement right here for model slash ship collection. Now you saw I already had one. That's because PhpStorm added it for me which your editor may or may not do. Down here when I had originally typed new ship collection and let it auto-complete it knew I needed the use statement so added it on top. One way or another make sure the use statement is there. About this method we're not returning an array of abstract ship objects anymore. We're now returning a ship collection.

Cool, now again don't worry about why we're doing this yet but this should completely break your application. Anywhere where we're calling get ships it's not returning an array anymore. It's returning an object and arrays and objects are completely different things so this is just going to break our code. Let's find out how it breaks our code and see if we can fix it. If you go to index.PHP first thing boom. Cannot use object of type ship collection as array, index.PHP line 13. No surprise. In fact the problem is when we get our ship's variable here which is a ship collection we try to add a broken ship to it by using the array syntax. Hey, you guys, we know how to make an object act like an array. You just need to make it implement slash array access, easy enough.

Now down at the bottom of the class I'll do the same thing I did before code generates, implement methods and I'll select my four methods. In this case for offset exists we'll return array key exists, offset this arrow ships. Then the other methods are actually really easy. Return this arrow ships, offset this arrow ships, offset, close value and unset this arrow ships, offset, perfect. We have a ship collection object, but when you interact with it like an array, you're effectively interacting directly with this array inside of it via these offset methods. Cool, we fixed that one. Refresh again. Awesome, it looks okay.

Let's start a battle here. Check this out. No ships. What's going on here? If you look back in index.PHP we eventually take that ship's variable and we loop over it. Of course, now this is a ship collection object. It turns out when you implement array access that allows you to use the array syntax but you still can't loop over it like an array, so when we loop over this object nothing happens and we get no ships. How can I make it possible to loop over an object as if it were an array? The answer is another interface. To add a second interface here we can say comma and then we'd say iterator aggregate. These right here are probably the two most common interfaces that you're going to implement.

We'll do the same trick again. We'll go do code generate, implement methods. This time we need just a single method called get iterator. The way to hook this up is actually to use another core class so you'll return new array iterator and pass that this era ships. The details of that aren't that important but basically this tells PHP you can loop over this object. When you do what I want you to do is actually just loop over the ships themselves, so if you go back, refresh, check it out guys, we have ships. We've successfully made this ship collection object look almost exactly like an array. There's still certain things that where it will differ between an array and the ship collection object. For the most part people that use it will have no idea that it's an object.

When you use third party libraries you should know that even though you loop over something it might be an object. Why is that important and why would we do this in the first place? Because sometimes it's useful to be able to add methods to your array. Of course, you can't do that but you can add methods to a class. For example, let's have a new method here called public function, remove all broken ships. Let's say sometimes it's convenient for you to get a ship collection object and say, "You know what, just get rid of all the broken ships." Instead of us needing to do that externally, we can just do it right here. Let's [inaudible 00:10:11] over this arrow ships. Then if ship arrow is functional, rather if not ship arrow is functional, we'll onset ship's key. Then we'll good.

Now finally, in index.PHP we can actually call ships arrow remove all broken ships. It looks and acts like an array but we have the power to add extra methods to it. That's awesome. Go back, refresh, check this out. Eventually you see a couple of ships get broken and actually get removed from the list. There are more of these interface methods that have special powers but these are the most important ones. The most important thing is just to understand that they exist and how they work.

